#!/usr/bin/python
# -*- coding: utf-8 -*-
import string
from typing import List, Union

from openfermion import QubitOperator, MolecularData, get_fermion_operator, jordan_wigner
from openfermionpyscf import run_pyscf
from openfermion.hamiltonians import fermi_hubbard
from openfermion.transforms import jordan_wigner


class GeneralHamiltonian:

    def __init__(self, system_size: int, interactions: List):
        self.system_size = system_size
        self.interactions = interactions

    def generate_hamiltonian(self) -> QubitOperator:
        ops = []
        for h_type, pos, coeff in self.interactions:
            if isinstance(pos, int):
                t_ = "{}{}".format(h_type, pos)
            else:
                t_ = " ".join(["{}{}".format(i, j) for i, j in zip(h_type, pos)])
            ops.append(QubitOperator(t_, coeff))

        qubit_hamiltonian = QubitOperator.accumulate(ops)

        return qubit_hamiltonian


class XXZ(GeneralHamiltonian):
    """  XXZ model  https://arxiv.org/pdf/2106.12627
        H_{XXZ} = \sum_{i:odd} J(X_i X_{i+1} + Y_i Y_{i+1} + \delta Z_i Z_{i+1}) +\sum_{i:even} (X_i X_{i+1} + Y_i Y_{i+1} + \delta Z_i Z_{i+1})
        parameters:
         J: float
         J_: float
         delta: float
    """

    def __init__(self, system_size: int, J_: float, J: float, delta: float, interactions: List = []):
        super().__init__(system_size, interactions)
        self.interactions = self.generate_interaction(J_, J, delta)
        self.H = self.generate_hamiltonian()

    def generate_interaction(self, J_, J, delta):
        coeff_J = [J if i % 2 == 0 else J_ for i in range(self.system_size - 1)]
        coeff_h = [delta] * self.system_size
        coeff = {'XX': coeff_J, 'YY': coeff_J, 'ZZ': [j_i * h_i for j_i, h_i in zip(coeff_J, coeff_h)]}
        interactions = []
        for key, value in coeff.items():
            for pos, coeff in zip([(i, i + 1) for i in range(self.system_size - 1)], value):
                interactions.append([key, pos, coeff])
        return interactions

class Heisenberg(GeneralHamiltonian):
    """  XXZ model  https://arxiv.org/pdf/2106.12627
        H_{XXZ} = \sum_{i:odd} J(X_i X_{i+1} + Y_i Y_{i+1} + \delta Z_i Z_{i+1}) +\sum_{i:even} (X_i X_{i+1} + Y_i Y_{i+1} + \delta Z_i Z_{i+1})
        parameters:
         J: float
         J_: float
         delta: float
    """

    def __init__(self, system_size: int, J_x: float, J_y: float, J_z, h: float, interactions: List = []):
        super().__init__(system_size, interactions)
        self.interactions = self.generate_interaction(J_x, J_y, J_z, h)
        self.H = self.generate_hamiltonian()

    def generate_interaction(self, Jx, Jy, Jz, h):
        coeff_Jx = [-Jx for i in range(self.system_size - 1)]
        coeff_Jy = [-Jy for i in range(self.system_size - 1)]
        coeff_Jz = [-Jz for i in range(self.system_size - 1)]
        coeff_h = [- h] * self.system_size
        coeff = {'ZZ': coeff_Jx, 'YY': coeff_Jy, 'ZZ':coeff_Jz, 'X': coeff_h}
        interactions = []
        for key, value in coeff.items():
            if key == 'ZZ' or 'YY' or 'XX':
                for pos, coeff in zip([(i, i + 1) for i in range(self.system_size - 1)], value):
                    interactions.append([key, pos, coeff])
            else:
                for pos, coeff in zip([i for i in range(self.system_size)], value):
                    interactions.append([key, pos, coeff])
        return interactions


class Transverse_fieldIsing(GeneralHamiltonian):
    """ Transverse Field Ising Hamiltonian
        Hamiltonian = -J (\sum_{<i,j>} Z_i Z_j + g\sum_j X_j)
    """

    def __init__(self, system_size: int, J: float, g: float, interactions: List = []):
        super().__init__(system_size, interactions)
        self.interactions = self.generate_interaction(J, g)
        self.H = self.generate_hamiltonian()

    def generate_interaction(self, J, g):
        coeff_J = [-J for i in range(self.system_size - 1)]
        coeff_h = [-J * g] * self.system_size
        coeff = {'ZZ': coeff_J, 'X': coeff_h}
        interactions = []
        for key, value in coeff.items():
            if key == 'ZZ':
                for pos, coeff in zip([(i, i + 1) for i in range(self.system_size - 1)], value):
                    interactions.append([key, pos, coeff])
            else:
                for pos, coeff in zip([i for i in range(self.system_size)], value):
                    interactions.append([key, pos, coeff])
        return interactions


class Molecular(GeneralHamiltonian):
    """ Molecular Hamiltonian generated by Openfermion
        https://quantumai.google/openfermion/tutorials/intro_to_openfermion
    """

    def __init__(self, geometry, interactions: List = []):
        super().__init__(system_size=0, interactions=interactions)
        self.basis = "sto-3g"
        self.multiplicity = 1
        self.charge = 0
        self.geometry = geometry
        self.H = self.generate_hamiltonian()

    def generate_hamiltonian(self):
        description = "tmp"
        molecule = MolecularData(self.geometry, self.basis, self.multiplicity, self.charge, description)
        molecule = run_pyscf(molecule, run_scf=1, run_fci=1)

        self.system_size = molecule.n_qubits
        self.fermionic_hamiltonian = get_fermion_operator(molecule.get_molecular_hamiltonian())

        qubit_hamiltonian = jordan_wigner(self.fermionic_hamiltonian)
        return qubit_hamiltonian


if __name__ == '__main__':
    nqubit = 10

    heisenberg = Heisenberg(nqubit, 1,1,1,0.5)
    print("\nThe Hamiltonian of heisenberg model is \n{}".format(heisenberg.H))

    xxz = XXZ(nqubit, .5, .6, 3)
    print("\nThe Hamiltonian of xxz model is \n{}".format(xxz.H))

    xxz = XXZ(nqubit, .5, .6, 3)
    print("\nThe Hamiltonian of xxz model is \n{}".format(xxz.H))

    h2 = Molecular(geometry=[('H', (0., 0., 0.)), ('H', (0., 0., 1.2))])
    print(print("\nThe Hamiltonian of H2 molecular is \n{}".format(h2.H)))

    ising = Transverse_fieldIsing(nqubit, .5, .2)
    s = ising.H
    print(print("\nThe Hamiltonian of  Transverse-field Ising model is \n{}".format(ising.H)))

